# Copyright (C) 2010 McAfee, Inc. All rights reserved
import subprocess
import sys
import os
import logging
import re
import shutil
import time

# Add common folder into the sys path for module importing
sys.path.append("../Common")
import commonFns
import LinuxShieldConfigParser
import commonAntiMalwareFns


def getODSExclusions() :
    """
    Function to get the OnDemand exclusions.
    """
    return LinuxShieldConfigParser.getExclusions(commonAntiMalwareFns.ODS_CONFIG, 'ODS')

def getODSExclusion(path) :
    """
    Function to return the exclusion having given path
    """
    return LinuxShieldConfigParser.getExclusion(commonAntiMalwareFns.ODS_CONFIG, 'ODS', path)


def deleteODSExclusion(path) :
    """
    Function to delete ODS Exclusion.
    """
    return LinuxShieldConfigParser.deleteExclusion(commonAntiMalwareFns.ODS_CONFIG, 'ODS', path)


def addODSExclusion(exclusion, exclusionName=None) :
    """
    Function to add an exclusion in ODS profile
    """
    return LinuxShieldConfigParser.addExclusion(commonAntiMalwareFns.ODS_CONFIG, 'ODS', exclusion, exclusionName)

def getODSResult(taskName) :
    """
    Fn to return the result dictionary for the given taskname :
    """
    _matched_records = commonAntiMalwareFns.searchDBLog(commonAntiMalwareFns.readSchedule, taskName, 'taskName', commonAntiMalwareFns.SCHEMA_SCHEDULE)
    if _matched_records is None or len(_matched_records) == 0 :
        return 0
    logging.debug("Record found. fetching results")
    _d_taskResult = dict()
    _s_taskResult = _matched_records[0]['taskResults']
    for item in _s_taskResult.split(',') :
        (_val, _key) = item.split(' ')
        _val.lstrip().rstrip()
        _key.lstrip().rstrip().rstrip("\n")

        _d_taskResult[_key] = _val
    return _d_taskResult

def deleteScheduledODSTask(taskName, profileName) :
    """
    Function to delete the scheduled on demand task
    """
    taskId = commonAntiMalwareFns.getScheduleId(taskName)
    if taskId <= 0 :
        logging.error("Could not find task with name %s" % taskName)
        return False

    if not deleteUnscheduledODSTask(taskName, profileName) :
        logging.error("Failed to remove task %s" % taskName)
        return False
    logging.debug("removing the crontab entry")
    if not commonAntiMalwareFns.deleteCrontabEntry(taskId) :
        logging.error("Failed to remove the crontab entry")
        return False
    return True

    
def deleteUnscheduledODSTask(taskName, profileName) :
    """
    Deletes an ODS Task from the database
    """
    if taskName is None or not isinstance(taskName, str) or len(taskName) == 0 :
        logging.error('"taskName" is must and should be a valid column name')
        return False
    if profileName is None or not isinstance(profileName, str) or len(profileName) == 0 :
        logging.error('"taskName" is must and should be a valid column name')
        return False
    logging.debug("Removing the profile, %s from the config file" % profileName)
    if not LinuxShieldConfigParser.deleteProfile(commonAntiMalwareFns.ODS_CONFIG, profileName) :
        logging.error("Failed to remove the config")
        return False
    logging.debug("Removing the task, %s from the schedule" % taskName)
    if not commonAntiMalwareFns.deleteTask({'taskName':taskName, 'taskType':'On-Demand'}) :
        logging.error("Failed to remove the row from table")
        return False
    return True

def getOnDemandStatus(taskName) :
    """
    Function to get the status of given Ondemand task
    """
    _query = 'select status from schedule where taskName = "' + taskName + '"'
    try :
        _p = subprocess.Popen([commonAntiMalwareFns.SQLITE, commonAntiMalwareFns.NAILS_DB, _query], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if not _p :
            logging.error("Query failed with error code : %d" % _status)
            logging.debug("Deleting the config profile for rollback")
            if not LinuxShieldConfigParser.deleteProfile(commonAntiMalwareFns.ODS_CONFIG, profileName) :
                logging.error("Failed to delete the profile %s " % profileName)
            return False
        _p.wait()

        _lines = _p.stdout.readlines()
        if len(_lines) == 0 :
            logging.error("No record found")
            return None
        return _lines[0].rstrip().lstrip().rstrip("\n")
    except :
        logging.error("Exception getting the taskStatus")
        return None

def createOnDemandTask(paths, taskName, profileName, profile=None, timeTable=None) :
    """
    @param paths - array of dict where each dict has following keys :
                     o 'path' - path which must be scanned (absolute path)
                     o 'exclude' - can have 'true' or 'false' strings (optional, default : false)
    @param taskName - string containing taskName to add (must not exist in db)
    @param profileName - unique profile for the ods-task [ must not already exist in the config ]
    @param profile - user can specify the profile values, otherwise values for ODS_default profile will be set.
                    [ see documentation of LinuxShieldConfigParser ]
    @param timeTable - a dict containing the below keys. If this parameter is not specified, 
                        'unscheduled' type will be assumed
                    o 'type' - one of ['unscheduled', 'once', 'daily', 'weekly', 'monthly' ]
                    o 'recurrence - string representation of number (e.g., '394' and not 394 )
                                    required when type is one of ['daily', 'weekly', 'monthly']
                    o 'day' - string rep of integer, required when 'type' is one of ['once', 'monthly'
                    o 'month' - string rep of integer, required when 'type' is one of ['once']
                    o 'year' - string rep of integer, required when 'type' is one of ['once' ]
                    o 'hour' - string rep of integer, required when 'type' is one of ['once', 'daily', 'weekly', 'monthly']
                    o 'minute' - string rep of integer, required when 'type' is one of ['once', 'daily', 'weekly', 'monthly']
                    o 'week' - string rep of integer, required when 'type' is one of ['monthly']
                    o 'days' - ';' seperated numbers in a string. required for type  ['monthly', 'weekly']
    """
    if paths is None or not isinstance(paths, list) or len(paths) == 0 :
        logging.error("Argument 'path' must be a string")
        return False
    if taskName is None or not isinstance(taskName, str) :
        logging.error("Argument 'taskName' must be a string")
        return False
    if profileName is None or not isinstance(profileName,str) :
        logging.error("Argument 'profile_name' must be a string")
        return False
    if timeTable is None :
        timeTable = {'type' : 'unscheduled' }
    if not isinstance(timeTable,dict) or len(timeTable) == 0 :
        logging.error("Argument 'timeTable' must be a dict")
        return False
    if not timeTable.has_key('type') or timeTable['type'] not in ['unscheduled', 'once', 'daily', 'weekly', 'monthly'] :
        logging.error("invalid value for 'type' in timeTable")
        return False
    if commonAntiMalwareFns.searchSchedule(taskName, 'taskName') :
        logging.error("TaskName %s is already existing" % taskName)
        return False
    # Convert paths from string to list and write logic for s_paths
    s_paths = ''
    for path in paths :
        if path is None or not isinstance(path, dict) :
            logging.error("Invalid value for 'path' provided.")
            return False
        if not path.has_key('path') or len(path['path']) == 0 :
            logging.error("Invalid value for 'path'.")
            return False
        if not path.has_key('exclude') or path['exclude'] != 'true' :
            path['exclude'] = 'false'
        s_paths = s_paths + "path:" + path['path'] + ';exclude:' + path['exclude']
    s_timeTable = commonAntiMalwareFns.getTaskTimeTable(dict(timeTable))

    if s_timeTable is None :
        return False

    _ods_profiles = LinuxShieldConfigParser.readAllProfiles(commonAntiMalwareFns.ODS_CONFIG)
    if _ods_profiles is None :
        logging.error("Failed to read ods.cfg to ")
    if profileName in _ods_profiles.iterkeys() :
        logging.error("Profile %s already exist. Please provide a new one." % profileName)
        return False
    if profile is None :
        profile = LinuxShieldConfigParser.readProfile(commonAntiMalwareFns.ODS_CONFIG, 'ODS_default')
        if profile is None :
            logging.error("Either you provided incorrect profile or failed to read default ods config")
            return False

    # add profile in the ods.cfg
    logging.debug("Setting the profile " + profileName)
    if not LinuxShieldConfigParser.setProfile(commonAntiMalwareFns.ODS_CONFIG, profileName, profile) :
        logging.error("Failed to add profile %s to ods.config" % profileName)
        return False

    # Find the latest taskId and add one.
    # Find the latest taskId in schedule and add one to it.
    _i_taskId = commonAntiMalwareFns.getScheduleMaxId()
    if _i_taskId <= 0 :
        logging.error("Invalid number %d returned as max taskId" % _i_taskId)
        logging.debug("Trying to rollback the profile addition activity")
        if not LinuxShieldConfigParser.deleteProfile(commonAntiMalwareFns.ODS_CONFIG, profileName) :
            logging.error("Failed to rollback the profile addition activity")
        return False

    # Add one to latest taskId and then create the unscheduled ods task
    _i_taskId = _i_taskId + 1
    

    # Add scheduled task
    _query = 'insert into schedule (i_taskId, taskName, timetable, taskType, taskInfo, status) ' +\
             'values (' + str(_i_taskId) + ', ' +\
                    '"' + taskName + '", ' +\
                    '"' + s_timeTable + '", "On-Demand", ' +'"profileName=' + profileName + ',paths=' + s_paths + '", "Idle")' 
                    
    logging.debug("Inserting record : %s" % _query)
    try :
        _status = subprocess.call([commonAntiMalwareFns.SQLITE, commonAntiMalwareFns.NAILS_DB, _query], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if _status != 0 :
            logging.error("Query failed with error code : %d" % _status)
            logging.debug("Deleting the config profile for rollback")
            if not LinuxShieldConfigParser.deleteProfile(commonAntiMalwareFns.ODS_CONFIG, profileName) :
                logging.error("Failed to delete the profile %s " % profileName)
            return False
        # Query to see if task exist or not.
        logging.debug("Searching if the taskName exist in database")
        if not commonAntiMalwareFns.searchSchedule(taskName) :
            logging.error("Though sqlite returned 0, the record is not added in database")
            logging.debug("Deleting the config profile for rollback")
            if not LinuxShieldConfigParser.deleteProfile(commonAntiMalwareFns.ODS_CONFIG, profileName) :
                logging.error("Failed to delete the profile %s " % profileName)
                return False
    except :
        logging.error("Exception occured during creation of record.")
        logging.debug("Deleting the config profile for rollback")
        if not LinuxShieldConfigParser.deleteProfile(commonAntiMalwareFns.ODS_CONFIG, profileName) :
            logging.error("Failed to delete the profile %s " % profileName)
        return False
    if timeTable is not None and timeTable.has_key('type') and timeTable['type'] in ['once', 'daily', 'weekly', 'monthly'] :
        entry = commonAntiMalwareFns.constructCronEntry(timeTable)   
        taskId = commonAntiMalwareFns.getScheduleId(taskName)
        if not commonAntiMalwareFns.writeCrontabEntry(entry, taskId) :
            logging.error("Failed to write entry %s into crontab" % entry)
            if not LinuxShieldConfigParser.deleteProfile(commonAntiMalwareFns.ODS_CONFIG, profileName) :
                logging.error("Failed to delete the profile %s " % profileName)
            if not commonAntiMalwareFns.deleteTask({'taskName':taskName, 'taskType':'On-Demand'}) :
                logging.error("Failed to remove task from database")
            return False
    return True



def setODSPrimaryAction(action):
    """
    Fn to set the ODS Primary Action
    @param action - string containing the action to set.
    """
    if action is None or not isinstance(action, str) :
        logging.error("commonAntimalwareFns.setODSPrimaryAction : Invalid argument")
        return False
    if action not in VALID_ACTIONS :
        logging.error("commonAntimalwareFns.setODSPrimaryAction : Invalid action %s" % action)
        return False
    if not LinuxShieldConfigParser.setConfig(commonAntiMalwareFns.ODS_CONFIG, {'nailsd.profile.ODS.action.Default.primary':action}) :
        logging.error('Failed to write into config file')
        return False
    return nailsReload()


def setODSSecondaryAction(action):
    """
    Fn to set ODS secondary action.
    @param action - string containing the action to set.
    """
    if action is None or not isinstance(action, str) :
        logging.error("commonAntimalwareFns.setODSSecondaryAction : Invalid argument")
        return False
    _primary_action = getODSPrimaryAction()
    if _primary_action == action :
        logging.error("Cannot set primary and secondary action to same")
        return False
    _valid_actions = commonAntiMalwareFns.getValidSecondaryActions(_primary_action)

    if action not in _valid_actions :
        logging.error("commonAntimalwareFns.setODSSecondaryAction : Invalid action %s" % action)
        return False
    if not LinuxShieldConfigParser.setConfig(commonAntiMalwareFns.ODS_CONFIG, {'nailsd.profile.ODS.action.Default.secondary':action}) :
        logging.error('Failed to write into config file')
        return False
    return nailsReload()


def getODSPrimaryAction():
    """
    Fn to get the primary action of OAS
    """
    return LinuxShieldConfigParser.getConfigKey(commonAntiMalwareFns.ODS_CONFIG, 'nailsd.profile.ODS.action.Default.primary')

def getODSSecondaryAction() :
    """
    Fn to get the secondary action of OAS
    """
    return LinuxShieldConfigParser.getConfigKey(commonAntiMalwareFns.ODS_CONFIG, 'nailsd.profile.ODS.action.Default.secondary')







