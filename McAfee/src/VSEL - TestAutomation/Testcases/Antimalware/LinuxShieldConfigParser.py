# Copyright (C) 2010 McAfee, Inc. All rights reserved
import re
import os
import logging
import sys
import time
BOOLEAN = 1
NUMBER  = 2
PATH    = 3
ACTION    = 4
FILTER   = 5

STRUCT_PROFILE = [ {
        'allFiles'            : BOOLEAN,
        'childInitTmo'        : NUMBER,
        'cleanChildren'       : NUMBER,
        'cleansPerChild'      : NUMBER,
        'datPath'             : PATH, 
        'deompArchive'        : BOOLEAN,
        'decompExe'           : BOOLEAN,
        'engineLibDir'        : PATH, 
        'enginePath'          : PATH, 
        'factoryInitTmo'      : NUMBER,
        'heuristicAnalysis'   : BOOLEAN,
        'macroAnalysis'       : BOOLEAN,
        'maxQueSize'          : NUMBER,
        'mime'                : BOOLEAN,
        'noJokes'             : BOOLEAN,
        'program'             : BOOLEAN,
        'quarantineChildren'  : NUMBER,
        'quarantineDirectory' : PATH,
        'quarantinesPerChild' : NUMBER,
        'scanChildren'        : NUMBER,
        'scanMaxTmo'          : NUMBER,
        'scanNWFiles'         : BOOLEAN,
        'scanOnRead'          : BOOLEAN,
        'scanOnWrite'         : BOOLEAN,
        'scannerPath'         : PATH,
        'scansPerChild'       : NUMBER,
        'slowScanChildren'    : NUMBER,
        'action'              : ACTION
    },
    {
        'filter'              : FILTER
    }
]

STRUCT_FILTER = {
        'path'   : PATH,
        'subdir' : BOOLEAN,
        'type'   : ['exclude-path']
}

def getConfigKey(filename, key) :
    """
    Private fn to read the key from the config file.
    """
    if key is None or not isinstance(key,str) :
        logging.error("key not specified or invalid type for key")
        return None
    logging.debug("Reading the config file")
    _cfg = getConfig(filename)
    if _cfg is None :
        logging.error("Failed to read the config file")
        return None
    logging.debug("Verifying if key is present.")
    if _cfg.has_key(key) :
        return _cfg[key]
    logging.error("%s not found in config file", key)
    return None


def setConfig(filename, config) :
    """
    Private Fn to read the config file and set the specified config to given value.
    @param filename : name of the file where the config value need to be set.
    @return True if successfully set. False Otherwise
    """
    if not os.path.exists(filename):
        logging.error("File %s does not exist" % filename)
        return False

    # read the file
    _lines = _readFile(filename)
    if _lines is None :
        return None
        
    for i in range(len(_lines)) :
        if re.match('#', _lines[i]) is not None or _lines[i].find(':') == -1 :
            continue
        _elements = _lines[i].split(':')
        key = _elements[0]
        value = _elements[1].rstrip().lstrip().rstrip("\n")
        if config.has_key(key) :
            _lines[i] = key + ': ' + config[key] + "\n"
            config.pop(key)
            if len(config) == 0:
                break
    else :
        logging.debug("Config not found in the file. Appending one")
        for key, value in config.items() :
            _lines.append( key + ': ' + value + "\n")

    try :
        # Now write back the file
        logging.debug("Writing contents in tmp file" + filename + '.TMP')
        _fh = open(filename + '.TMP', 'w')
        if _fh is None :
            logging.errror("Failed to open config file %s for writing" % filename)
            return False
        for _line in _lines :
            _fh.write(_line)
        _fh.close()
        time.sleep(1)
    except :
        logging.error("Failed to open the config file for writing ")
        return False
    # now move to actual file
    logging.debug("Now moving tmp file to actual file")
    os.rename(filename + ".TMP", filename)
    return True

def getConfig(filename) :
    """
    Fn to read the given config file and return a dict
    """
    if not os.path.exists(filename) :
        logging.error("Path %s does not exist" % filename)
        return None
    # read the file
    _lines = _readFile(filename)
    if _lines is None :
        logging.debug("None is retuning from getConfig")
        return None
        
    try :
        _cfg = dict()
        for _line in _lines :
            if re.search("^#", _line) is not None :
                continue
            _m = re.search('^(.*?):\s*(.*)$', _line)
            if _m is not None :
                _cfg[_m.group(1)] = _m.group(2)
        return _cfg
    except IOError, e:
        logging.error("Failed to open config file %s " % e.strerr)
        return None


def deleteConfigKey(filename, key) :
    """
    Private fn to delete the key from given config
    """
    if not os.path.exists(filename):
        logging.error("File %s does not exist" % filename)
        return False
    if key is None or value is None or not isinstance(key, str) or not isinstance(value, str) :
        logging.error("Invalid parameter passed for _setNailsConfig")
        return False

    # read the file
    _lines = _readFile(filename)
    if _lines is None :
        return None
    if _writeFile(filename + '.TMP', _lines, '^' + key + ':') :
        os.rename(filename + '.TMP', filename)

def getProfile(filename, profile_name) :
    return readProfile(filename, profile_name)

def readProfile(filename, profile_name) :
    """
    Fn to read the profile from the given config file.
    """
    _lines = _readFile(filename)
    if _lines is None :
        return None
    profile = dict()
    for _line in _lines :
        if not re.match('nailsd\.profile\.' + profile_name + '\.', _line) :
            continue

        (_key, _value) = _line.split(':')
        _value = _value.rstrip().lstrip().rstrip("\n")
        _elements = _key.split('.')[3:]
        if len(_elements) == 1 :
            profile[_elements[0]] = _value
        else :
            _key = _elements.pop(0)
            if not profile.has_key(_key) :
                profile[_key] = dict()
            _p_k_value = profile[_key]
        
            while len(_elements) > 1 :
                _key = _elements.pop(0)
                if not _p_k_value.has_key(_key) :
                    _p_k_value[_key] = dict()
                _p_k_value = _p_k_value[_key]
            _key = _elements.pop(0)
            _p_k_value[_key] = _value
    return profile

def _writeFile(filename, lines, pattern) :
    """
    Private function to write the lines which does not match the pattern
    into the given file
    """
    _fh = open(filename, 'w')
    if _fh is None :
        logging.errror("Failed to open config file %s for writing" % filename)
        return None
    try :
        for _line in lines :
            if re.search(pattern, _line) is None:
                _fh.write(_line)
    except :
        logging.error("Failed to open the config file for reading ")
        return False
    finally :
        _fh.close()
    return True

def readAllProfiles(filename) :
    """
    Fn to read the profile from the given config file.
    """
    _lines = _readFile(filename)
    if _lines is None :
        return None
    profile = dict()
    for _line in _lines :
        if not re.match('nailsd\.profile\.', _line) :
            continue

        (_key, _value) = _line.split(':')
        _value = _value.rstrip().lstrip().rstrip("\n")
        # Split on '.'
        _elements = _key.split('.')[2:]
        if len(_elements) == 1 :
            profile[_elements[0]] = _value
        else :
            _key = _elements.pop(0)
            if not profile.has_key(_key) :
                profile[_key] = dict()
            _p_k_value = profile[_key]
        
            while len(_elements) > 1 :
                _key = _elements.pop(0)
                if not _p_k_value.has_key(_key) :
                    _p_k_value[_key] = dict()
                _p_k_value = _p_k_value[_key]
            _key = _elements.pop(0)
            _p_k_value[_key] = _value
    return profile

def deleteProfile(filename, profile_name) :
    """
    Fn to delete the given profile name
    """
    if not os.path.exists(filename):
        logging.error("File %s does not exist" % filename)
        return False
    if profile_name is None or not isinstance(profile_name, str) : 
        logging.error("Invalid parameter passed for _setNailsConfig")
        return False

    # read the file
    logging.debug("Reading the config file %s" % filename)
    _lines = _readFile(filename)
    if _lines is None :
        logging.error("No content found for file")
        return False
    logging.debug("Now creating temporary file")
    if _writeFile(filename + '.TMP', _lines, '^nailsd\.profile\.' + profile_name + '\.' ) :
        logging.debug("Copying the temporary file to original file %s " % filename)
        os.rename(filename + '.TMP', filename)
        return True

    logging.debug("Failed to write to temporary file")
    return False
def setProfile(filename, profile_name, profile) :
    """
    Fn to write the profile 
    """
    # Validate
    if profile_name is None or not isinstance(profile_name, str) or profile_name in ['OAS_Default', 'ODS_Default'] :
        return False
    # Now convert profile to key/value dict
    logging.debug("Converting profile to a config")
    _config = _profile_to_config(profile_name, profile)
    logging.debug("Deleting the existing the profile")
    deleteProfile(filename, profile_name)

    logging.debug("Setting the config")
    if not setConfig(filename, _config) :
        logging.error("Failed to set config")
        return False
    return True
def isProfileValid(profile) :
    """
    Function to verify if the profile is valid or not.

        The valid keys for the profile are :
            o allFiles -string, [ 'true', 'false']  
            o childInitTmo: string, must be a number
            o cleanChildren: string, must be a number
            o cleansPerChild: string, must be a number (e.g., '10000')
            o datPath: string (must be a path)
            o decompArchive: string, [ 'true', 'false']  
            o decompExe: string, [ 'true', 'false']  
            o engineLibDir: string (path)
            o enginePath: string (must be a path)
            o factoryInitTmo:string, must be a number 
            o heuristicAnalysis: string ('true', 'false') 
            o macroAnalysis:string ('true', 'false')  
            o maxQueSize: string, must be a number 
            o mime: string ('true', 'false')  
            o noJokes: string ('true', 'false')  
            o program: string ('true', 'false')  
            o quarantineChildren:string, must be a number 
            o quarantineDirectory: /quarantine
            o quarantinesPerChild: string, must be a number
            o scanChildren: string, must be a number
            o scanMaxTmo: string, must be a number
            o scanNWFiles: string ('true', 'false')  
            o scanOnRead: string ('true', 'false')  
            o scanOnWrite: string ('true', 'false')  
            o scannerPath: /opt/NAI/LinuxShield/libexec/scanner
            o scansPerChild: string, must be a number
            o slowScanChildren: string, must be a number
            o action
                o encrypted: string ('Pass')
                o error: Block
                o timeout: Pass
                o App.primary: Clean
                o App.secondary: Quarantine
                o Default.primary: Clean
                o Default.secondary: Quarantine
            o filter - a dict whose key is name of filter
                o <name_of_filter>
                    o path: string - path 
                    o subdir: string - 'true' or 'false'
                    o type: string ['exclude-path']
    """
    if profile is None or not isinstance(profile, dict) :
        logging.error("Invalid Profile")
        return False
    # Check for required keys

    for key in STRUCT_PROFILE[0].keys() :
        if key not in profile.keys() :
            logging.error("The required key %s is missing" % key)
            return False
    # Check if any extra keys are provided
    for key, value in profile.keys() :
        if key not in STRUCT_PROFILE[0].keys() and key not in STRUCT_PROFILE[1].keys() :
            logging.error("The key %s is not invalid" % key)
            return False
        if key in STRUCT_PROFILE[0].keys and not _isValidProfileValue(value, STRUCT_PROFILE[0][key]) :
            logging.error("Value for %s is wrong" % key)
            return False
       
def _isValidProfileValue(value, type) :
    """
    Checks if the value is valid or not.
    """
    if value is None or not isinstance(value, str) or not isinstance(value, dict) or not isinstance(value, list) :
        logging.error("Invalid value type")
        return False
    if type == PATH :
        return os.path.exists(value)
    elif type == BOOLEAN :
        return value in ['true', 'false']
    elif type == NUMBER :
        if re.search('^\d+$', value) is not None :
            return True
        return False
    elif type == FILTER :
        for filter in value :
            if not _isValidFilter(filter) :
                return False
    elif type == ACTION :
        return _isValidAction(value)
    return True

def _isValidAction(action) :
    logging.debug("Not yet Implemented")
    return True

def _isValidFilter(filter) :
    logging.debug("Not yet implemented")
    return True

def _dict_to_lines(profile) :
    lines = []
    for key, value in profile.items() :
        if isinstance(value,str) :
            lines.append(key + ':' + value )
        else :
            _v_to_l = _dict_to_lines(value)
            for e in _v_to_l :
                lines.append(key + '.' + e)
    return lines

def _profile_to_config(profile_name, profile) :
    lines = _dict_to_lines(profile)
    s_dict = dict()
    for line in lines :
        (key, value) = line.split(':')
        s_dict['nailsd.profile.' + profile_name + '.' + key] = value
    return s_dict



def _readFile(filename) :
    # read the file
    _fh = open(filename, 'r')
    if _fh is None :
        logging.errror("Failed to open config file %s" % filename)
        return None
    _lines = _fh.readlines()
    _fh.close()
    return _lines




def getExclusion(filename, profileName, path) :
    """
    Function to return the exclusion of given profile.
    """
    all = getExclusions(filename, profileName)
    for fn, excl in all.items() :
        if excl.has_key('path') and excl['path'] == path :
            return excl
    logging.error("Exclusion not found ")
    return None

def getExclusions(filename, profileName):
    """
    Function to return all exclusions of the given profile
    """
    filter = {}
    profile = getProfile(filename, profileName)
    if profile is None :
        logging.error("Failed to retrieve the %s config" % profileName)
        return None
    if profile.has_key('filter') :
       [ filter.__setitem__(x,y)  for x, y in profile['filter'].items() if y.has_key('type') and y['type'] == 'exclude-path' ]
    return filter


def addExclusion(filename, profileName, exclusion, exclusionName=None) :
    """
    Function to set the ODS exclusion
    """
    if exclusion is None or not isinstance(exclusion, dict) or not exclusion.has_key('path') or not exclusion.has_key('subdir') :
        logging.error("Invalid exclusion.")
        return False
    
    if len(exclusion['path']) == 0 :
        logging.error('Length of path in exclusion is 0')
        return False
    if exclusion['subdir'] != 'true' :
        exclusion['subdir'] = 'false'
    
    exclusion['type'] = 'exclude-path'

    profile = getProfile(filename, profileName)
    if profile is None :
        logging.error("Failed to retrieve the %s config" % profileName)
        return False
    existing_filter = {}
    # Find matching profiles
    if profile.has_key('filter') :
        [existing_filter.__setitem__(x,y) for x,y in profile['filter'].items() if y.has_key('type') and y['type'] == 'exclude-path' and y['path'] == exclusion['path'] ]
    if len(existing_filter) != 0 :
        logging.error("An exclusion for path %s already exist" % exclusion['path'])
        return False
    
    if exclusionName is None :
        _cnt = 0
        while True :
            if profile['filter'].has_key(str(_cnt)) :
                _cnt += 1
            else :
                break
        exclusionName = str(_cnt)
    elif exclusionName is not None and profile['filter'].has_key(exclusionName) :
        logging.error("Exclusion with the name %s already exist" % exclusionName)
        return False
    
    profile['filter'][exclusionName] = exclusion
    if not setProfile(filename, profileName, profile) :
        logging.error("Failed to set the exclusion to % profile" % profileName)
        return False
    return True

def deleteExclusion(filename, profileName, path) :
    if path is None or len(path) == 0 :
        logging.error("Invalid path provided for deleteExclusion")
        return False

    profile = getProfile(filename, profileName)
    if profile is None :
        logging.error("Failed to retrieve the %s config" % profileName)
        return False
    existing_filter = []
    if profile.has_key('filter') :
        existing_filter = [x for x,y in profile['filter'].items() if y.has_key('type') and y['type'] == 'exclude-path' and y['path'] == path ]
    if len(existing_filter) == 0 :
        logging.error("Exclusion not found for path : " + path)
        return False

    for ef in existing_filter :
        del profile['filter'][ef]
    if not setProfile(filename, profileName, profile) :
        logging.error("Failed to delete the exclusion from %s profile" % profileName)
        return False
    return True








