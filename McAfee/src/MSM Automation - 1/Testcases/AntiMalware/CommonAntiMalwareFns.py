# Copyright (C) 2010 McAfee, Inc. All rights reserved
import subprocess
import shlex
import sys
import os
import logging
import re
import time
# Add common folder into the sys path for module importing
sys.path.append("../Common")
import commonFns
import decimal

QATT_PATH = os.path.abspath(os.path.dirname(os.path.abspath(sys.argv[0])) + "/../data/qatt/QATestTool")

OAS_ENABLE               =  "OAS_Enable"

def checkOASScannersUsable():
    _maxTimeLimit = 0
    cpuUsage = 100
    # Making sure the 'cpu usage' of Scanners is below 5%. In check we are using '2'
    # instead of '5' because we are getting two snapshots of 'top' command.   
    while cpuUsage > 2 and _maxTimeLimit < 300:
        _cmd = "top -F -R -l 2 | grep VShieldSca | awk 'BEGIN {print $2, $3} {s+=$3} END {if (NR>0) {print s/NR} else {print \"100\"}}'"
        _p = subprocess.Popen(['/bin/sh', '-c', _cmd], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # Wait till process complete.
        _p.wait()
        # Read the output and parse it.
        _out = _p.stdout.read().split("\n")
        _linNum = 1
        for _line in _out :
            if _linNum == 2:
                cpuUsage = decimal.Decimal(_line.strip())
            _linNum += 1
        if cpuUsage <= 2:
            return True
        _maxTimeLimit += 5
        time.sleep(5)

    if _maxTimeLimit < 300:
        return True
    else:
        return False

def enableOAS():
    """
    Enable On-Access-Scan
    RETURN : True on success, False otherwise
    """
    _result = setKey("OAS_Enable","1")

    if _result == False:
        return False
    else:
        return checkOASScannersUsable()

def disableOAS():
    """
    Disable On-Access-Scan
    RETURN : True on success, False otherwise
    """
    _result =  setKey("OAS_Enable","0")

    if _result == False:
        return False
    else:
        _maxTimeLimit = 0
        # Check if all the 'Scanners' are down.
        while commonFns.isProcessRunning("VShieldScanner") == True and _maxTimeLimit < 120:
            time.sleep(5)
            _maxTimeLimit += 5
        
        if _maxTimeLimit < 120:
            return True
        else:
            return False       


def isOASEnabled():
    """
    Return the status of the On-Access-Scan
    RETURN : True if OAS is enabled, False otherwise
    """
    return getKey('OAS_Enable') in ["true"]

def createEicarInfection(file):
    eicarData = "X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
    try:
        fileH = open(file, 'w')
        fileH.writelines(eicarData)
        fileH.close()
        return True 
    except:
        return False

def createInstallCheckInfection(file):
    eicarData = "ZQZXJVBVT"
    try:
        fileH = open(file, 'w')
        fileH.writelines(eicarData)
        fileH.close()
        return True 
    except:
        return False

def resetToDefaults():
    """
    Resets the Scanner to default factory settings.
    NOTE: All OAS, ODS and Exclusions are set to factory settings.
    RETURN : True on success, False otherwise
    """
    try :
        _retval = subprocess.call([QATT_PATH, '5'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE)
        if _retval == 0 :
            return True
    except :
        logging.error("resetOASToDefaults : Exception occured while running QATT")
    return False



def clearQuarantine():
    """
    Clears the quarantine
    RETURN : True if successfully cleared. False otherwise
    """
    _quarantine = getQuarantineList()
    if _quarantine is None :
        return False
    _ids = _quarantine.keys()
    _cmd = [QATT_PATH, '7']
    for _id in _ids :
        _cmd.append(_id)
    try :
        _retval = subprocess.call(_cmd, stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)
        if _retval != 0 :
            logging.error("Failed to deleted the Ids")
            return False
        time.sleep(5)
        return True
    except :
        logging.error("clearQuarantine : Failed to clear")
        return False

def isFileQuarantined(file_path):
    """
    Checks if the file is quarantined or not
    RETURN : True if file is Quarantined and False Otherwise
    """
    _quarantine = getQuarantineList()
    if _quarantine is None :
        return False
    
    # Check if it is present.
    for _val in _quarantine.values() :
        if _val == file_path :
            return True
    return False

def getQuarantineList():
    """
    Runs QATT to get the quarantine list.
    RETURN : a dictionary containing the Quarantine ID as key and
             file_path as the value
             None - if failed to get the list
    """
    # Get the list of Quarantined files using QATT
    try :
        logging.debug("getQuarantineList : Running QATT to get Quarantine list")
        _p = subprocess.Popen([QATT_PATH, '6'], stdout=subprocess.PIPE,
                stderr=subprocess.PIPE)
        if _p is None :
            logging.error("getQuarantineList : Failed to run QATT to get Quarantine list")
            return None
        _p.wait()

        _out          = _p.stdout.read().split("\n")
        _header_found = False
        _quarantine   = dict()
        _regex_header = "Name\s+QID\s+Time"
        _regex_file   = "(.*)\s+(\d+)\s+\w{3}\s\w{3}\s+\d\d?\s+\d\d:\d\d:\d\d\s+\d{4}"

        for _line in _out :
            if _header_found :
                _match = re.search(_regex_file, _line)
                if _match is None :
                    continue
                _quarantine[_match.group(2)] = _match.group(1).strip()
            elif re.search(_regex_header,_line) is not None :
                _header_found = True
    except :
        logging.error("getQuarantineList : Exception occured!")
        return None
    return _quarantine

def getKey(key):
    try :
        _p = subprocess.Popen([QATT_PATH, "2", key], stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        if _p is None :
            #logging.error("Unable to create the QATT process")
            return False
        # Wait till process complete.
        _p.wait()

        # Read the output and parse it.
        _out = _p.stderr.read().split("\n")
        _regex = "\{contents\s+=\s+\"%s\"\s*\}.*\{value\s+=\s+(.*)\}" % key
        logging.debug("REGEX - %s" % _regex)
        for _line in _out :
            logging.debug(_line)
            _match = re.search(_regex, _line)
            if _match is not None :
                _val = _match.group(1).strip()
                logging.debug("Value for %s is %s" % (key, _val))
                return _val
        logging.debug("Key %s not found" % key)
        return None
    except :
        logging.error("getKey : Exception occured while running QATT")
        return None


def setKey(key,value):
    try :
        _cmd = QATT_PATH + " 3 " + key + " " + value
        args = shlex.split(_cmd)
        _p = subprocess.Popen(args, stdout=subprocess.PIPE,
                stderr=subprocess.PIPE)
        if _p is None :
            logging.error("setKey : Failed to launch QATT")
            return None
        _p.wait()
        if _p.returncode == 0 :
            return True
    except :
        logging.error("setKey : Exception occured while running QATT")
    return False

def getMD5ForFile(file):
    try:
        _OASState = 0
        if isOASEnabled() == True:
            _OASState = 1
            disableOAS()

        _md5Val = commonFns.getMD5ForFile(file)

        if _OASState == 1:
            enableOAS()

        return _md5Val
    except:
        return None

    return None


def checkVShieldServiceUsable():
    _maxTimeLimit = 0
    cpuUsage = 100

    # Making sure the 'cpu usage' of VShieldService is below 2%.    
    while cpuUsage > 2 and _maxTimeLimit < 120:
        _cmd = "top -F -R -l 2 | grep VShieldSer | awk 'BEGIN {print $2, $3} {s+=$3} END {if (NR>0) {print s/NR} else {print \"100\"}}'"
        _p = subprocess.Popen(['/bin/sh', '-c', _cmd], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
   
        # Wait for process to complete
        _p.wait()

        # Read the output and parse it.
        _out = _p.stdout.read().split("\n")
        _linNum = 1
        for _line in _out :
            if _linNum == 2:
                cpuUsage = decimal.Decimal(_line.strip())
            _linNum += 1
        if cpuUsage <=2:
            return True
        time.sleep(5)
        _maxTimeLimit += 5

    if _maxTimeLimit < 120:
        # Additional sleep to take care of any rare scenarios...
        time.sleep(5)
        return True
    else:
        return False

def installAntiMalwareTestTool():
    """
    Fns to install anti-malware test tool.  This fn will also wait for VShieldService process to come up
    """

    # Install AppProt test tool
    if commonFns.installTestTool("qatt", os.path.dirname(os.path.dirname(\
            os.path.abspath(sys.argv[0]))) + "/data/qatt") != True :
        return 1

    os.unsetenv("TMPDIR")
    _retVal = checkVShieldServiceUsable();
    return _retVal

