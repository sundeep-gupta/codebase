#!/tools/bin/perl

=head NAME
flowcontrol.pl

=head1 DESCRIPTION

=head2 Test Category
Performance

=head1 ENVIRONMENT


=head1 APPLICATIONS
=cut
=head1 bugs
=cut

=head1 Authors

=cut 

use lib '/tools/lib/perl5/site_perl/5.8.4';
use lib '/tools/tests/regression';
use Test::More  qw(no_plan); 
use Time::localtime;  
use Carp ;
use Getopt::Std ;
use XMLRPC::Lite;
use Data::Dumper;
use orbital_rpc;


my $testcase="flowcontrol";
my $max_bw = 500;                  #max default is 500 Mbps
my $ratio = 0.90;                  #expect thrput without compression
my $duration = 60;
my @rtt_list = (0, 100, 200, 300);  
my @sess_list = (1, 100, 500);                 #This list is proposed by Daniel 
my $log_dir = '/var/tmp/';
my $dr = "20.20.20.1";           #default Delay Router 
#my $log_dir = '/logs/regression_results/';
#Require @least 2 inputs: the tested ORB and the IPERF Server.
# c=1 turn on compression
# m = 1 email the results out
#----------------------------------------------------------
getopt ("r,o,s,c,m") ;

if (  ! $opt_s || ! $opt_o || !$opt_r ) {
  print "Usage: $testcase -d <dr> -r <remote_orb>  -o <OrbIP> -s <Iperf Server> |-c <1> |-m <1> \n" ;
  exit 1 ;
}
my $comp = 0;                                  #default is no compression
if ($opt_c) { $comp = $opt_c; chomp ($comp) };
if ($comp) { $ratio = 2.5 }                    #set to 2.5x for compression

my $send_mail = 0;                #default is not sending email
if ($opt_m) { $send_mail = $opt_m; chomp ($send_mail) };

my $host = $opt_s;
chomp ($host );
my $orb = $opt_o; chomp ($orb);       #setup the Orb for XMLRPC
my $url = "http://$orb:2050/RPC2";
my $rpc = Orbital::Rpc->new($url);
my $version = $rpc->get_system_variable("Version");

my $remOrb = $opt_r; chomp ($remOrb);       #setup the Orb for XMLRPC
my $remOrb_url = "http://$remOrb:2050/RPC2";
my $remOrb_rpc = Orbital::Rpc->new($remOrb_url);


my $sess =1;
my $expected_rate;
my $sleep_time = $duration + 10; #Tune this value, for test with large number of sessions.
my $tm=localtime;
$tm = sprintf("%02d%02d%04d", $tm->mday,($tm->mon)+1, $tm->year+1900);

@version = split(/\s+/, $version);
my $i =0;
my $release="";                         #The short form 
while ($version[$i]) {
  if ($version[$i++] eq "Release" ){     #$i now at the version number
     $release = "$version[$i++]"."-";        #$i now pointing at "Build"
     my $subver =  int ($version[++$i]) ;
#     print "Version sub:  $subver \n";
     $release = "$release"."$subver"; }
}
printf "THE TESTED VERSION: %8s \n", $release;     

#create the individual log file
#my $log_file = "$log_dir"."NonComp_"."$testcase"."_$tm".".log";
my $log_file = "$log_dir"."NonComp_"."$testcase"."_$release"."_$tm".".log";
if ($comp) { $log_file = "$log_dir"."Comp_"."$testcase"."_$release"."_$tm".".log";}
print "this is the log file: $log_file \n";
open (LOG,  "> $log_file") || die "Could not open the file $log_file \n";

#The stat file retains all the performance test results. Data is appent to the file.
my $stat_file = "$log_dir"."$testcase"."_stats".".log"; #contains perf results of all individual test.
if (-e $stat_file) {
   open (STAT,  ">> $stat_file") || die "Could not open the file $stat_file \n";
   } else {                       #file is not there
   open (STAT,  "> $stat_file") || die "Could not open the file $stat_file \n";
#Create the file header
   print STAT '-' x125;
   printf STAT "\n%26s%9s%9s%9s%9s%9s%9s%9s%9s%9s%9s%9s\n",'0 RTT','0 RTT','0 RTT','100 RTT','100 RTT','100 RTT','200 RTT','200 RTT','200 RTT','300 RTT','300 RTT','300 RTT';
   print STAT '-' x125;
   printf STAT "\n%8s%9s%9s%9s%9s%9s%9s%9s%9s%9s%9s%9s%9s%9s\n",'Date','Release','1sess','100sess','500sess','1sess','100sess','500sess','1sess','100sess','500sess','1sess','100sess','500sess';
   print STAT '-' x125, "\n";
}

#stamp the date & release to the log file
printf STAT "\n%8s%9s", $tm, $release;

# By default, this test is w/o compression.
print "\nThe Current Compression Status: ", $rpc->get_parameter('Compression.EnableCompression'),"\n";
if ($comp) {
   print "Set Compression On... ", $rpc->set_parameter('Compression.EnableCompression', '1'), "\n"
   } else {
   print "Set Compression Off... ", $rpc->set_parameter('Compression.EnableCompression', '0'), "\n";
   }
print "\nThe Tested Compression Setting: ", $rpc->get_parameter('Compression.EnableCompression'),"\n";


#Initialize the  Orbs
   my $bw_bs = $max_bw * 1000;        #bit/sec required for Orb send-rate setting
   print LOG "Set SendRate To: ", $rpc->set_parameter('SlowSendRate', $bw_bs);
   sleep 3;
   if ($bw_bs == $rpc->get_parameter('SlowSendRate')) {
          print LOG "The SendRate was sucessfully set: $bw_bs \n";
       } else {
          print LOG "The SendRate is not properly set to $bw_bs \n";
          print LOG "The current SendRate is: ", $rpc->get_parameter('SlowSendRate'), "\n";
          exit; }
foreach $rtt (@rtt_list) {
   $expected_rate = ($max_bw * $ratio);
   config_CNISTNET ($dr, $dr_dest, $max_bw, $rtt, '0.1');
   sleep 3;
   
   foreach $sess (@sess_list) {
      if ($comp) {
         print "Reset Compression History ", $rpc->set_parameter('Compression.EnableCompression', '0'), "\n";
         print "...", $rpc->set_parameter('Compression.EnableCompression', '1'), "\n"}
      if ($sess == 1) {                 	#handle this case separately
         is (run_perf ($host, $bw, $duration), 1, "Performance: $sess session over $bw Mbps") ;
         sleep 5;
         print LOG "------------------------------------\n\n";
         } else {                #if number of tested sessions are more than 1
          is (run_perfs ($host, $bw, $duration, $sess), 1, "Performance: $sess sessions over  $bw Mbps") ;
          sleep 5;
          print LOG "------------------------------------\n\n";
      }      #fi
   }
}

if ($comp) {
   printf STAT "%8s\n\n", 'COMP';              #Stamp the result of either compress or non-compress
   } else {
       printf STAT "%8s\n\n", 'NO-COMP';
       }              
    
#Test Completed. Send the result out.

if ($send_mail) {
   print LOG "\nEmail the results ..\n";
   print `mail \-s \"Performance Test Results $release\" engineering\@orbitaldata.com \< $stat_file`;
#    print `mail \-s \"Performance Test Results\" dong\@orbitaldata.com \< $stat_file`;
   }


#********************************************************  
sub run_perf
{
    my $host = shift ;
    my $bw = shift;
    my $duration = shift ;
    my $pass="FAIL";
    my $number = '0.00';       #Print this value when test fails to collect results
    my $unit= 'Kbits/sec';
    my @rate="";
# format: change_dr (<dr ip> <rem_net> <bw> <rtt> <drop>)
#    $bw_Kb = $bw * 1000;     #convert to Kbps
#    config_DR ($dr, $net1_add, $bw_Kb, $rtt, 0);
#    sleep 10;
#Start Performance test
    my $test = "/usr/local/bin/iperf -c $host -t $duration";
    print LOG "Invoke: $test \n";
    my $result = `$test | tail -1`;
    sleep 5;

#Verify the results ..
   if ($result) {
      print LOG "/nThe Result is succesfully collected \n";
      @rate = split(/\s+/, $result);
      $unit = pop(@rate);
      $number = pop(@rate); 
      }
   print LOG "Performance Test of $sess over $bw\n";
   print LOG "The expected rate: $expected_rate Mbits/sec\n";
   print LOG "The actual rate  : $number $unit \n";
   if ( ($number >= $expected_rate) && ($unit eq "Mbits/sec" )) {
      print LOG "Throughput is in the expected range - PASS! \n";
      $pass = PASS;
      printf STAT "%9.2f", $number;
      return 1;
      } elsif ($unit eq "Mbits/sec") {
           print LOG "Throughput is NOT in the expected range - FAIL! \n";
           printf STAT "%9.2f", ($number);
           return  0 ;
           } elsif ($unit eq "Kbits/sec") {
                $number = $number/1000;
                if ($number >= $expected_rate) {
                    print LOG "Throughput is in the expected range - PASS! \n";
                    printf STAT "%9.2f", $number;
                    $pass = PASS;
                    return 1;
                    } else {
                        print LOG "Throughput is NOT in the expected range - FAIL! \n";
                        printf STAT "%9.2f", $number;
                        return  0 ;
                        }
                }
}

#*************************************************************************
#This sub is for multiple sessions 
sub run_perfs
{
    my $host = shift ;
    my $bw = shift;
    my $duration = shift ;
    my $sess = shift;
    my $pass = FAIL;
    my $number = '0.00';
    my $unit= 'Kbits/sec';
    my @rate;
    my $temp_log= "$log_dir"."$testcase"."_temp.log";
#Try this.. "iperf_c.sh <host> <sessions> <duration>
    my $test = "/tools/tests/regression/iperf_c.sh $host $sess $duration > $temp_log &";
    print LOG "Invoke: $test \n";
    my $result = `$test`;

#Wait for the test to complete ...
   print LOG "SLEEP $sleep_time \n";
   sleep $sleep_time;

# Gather the  results ..
   print LOG  `cat $temp_log`;
   $result = `cat $temp_log | grep SUM`;
   my $i = 1;
   while (! $result && ($i < 10)) {    #wait an extra (max) 450 sec before failing
     print LOG "The Result is not ready...Sleep 50 Sec \n";
     sleep 50;
     $result = `cat $temp_log | grep SUM`;
     $i++;
     }                       #wait until the test is completed
      
   kill_iperf();
   sleep 10;
   if ($result) {
      @rate = split(/\s+/, $result);
      $unit = pop(@rate);
      $number = pop(@rate);
      } 
   print LOG "Performance Test of $sess over $bw\n";
   print LOG "The expected rate: $expected_rate Mbits/sec\n";
   print LOG "The actual rate  : $number $unit \n";
   if ( ($number >= $expected_rate) && ($unit eq "Mbits/sec" )) {
      print LOG "Throughput is in the expected range - PASS! \n";
      $pass = PASS;
      printf STAT "%9.2f", $number;
      return 1;
      } elsif ($unit eq "Mbits/sec") {
           print LOG "Throughput is NOT in the expected range - FAIL! \n";
           printf STAT "%9.2f", ($number);
           return  0 ;
           } elsif ($unit eq "Kbits/sec") {
                $number = $number/1000;
                if ($number >= $expected_rate) {
                    print LOG "Throughput is in the expected range - PASS! \n";
                    printf STAT "%9.2f", $number;
                    $pass = PASS;
                    return 1;
                    } else {
                        print LOG "Throughput is NOT in the expected range - FAIL! \n";
                        printf STAT "%9.2f", $number;
                        return  0 ;
                        }
                 } 
}
#*************************************************************************
sub config_DR
#Need 4 inputs: <DR IP> <REM-NETWORK> <BW> <RTT> <LOSS>
{
  print LOG "Configure the DR: $_[0]\n";
  my $set_dr = "ssh $_[0] \".\/set_bw.sh $_[1] $_[2] $_[3] $_[4]\" ";
  $set_dr = `$set_dr`;
  print LOG "Below is the DR configuration: \n $set_dr \n";
}
 
#*************************************************************************
sub kill_iperf
{
 my $string = `ps -e | grep iperf | tail -1 `;
 print LOG "This Iperf process is running $string \n";
 my @field = split(/\s+/,$string);
 my $counter=0;
 if ($field[0] eq "") {$counter++}
 if (( $string =~ /iperf/)) {
  if (`kill $field[$counter]`) {
           print LOG  "The Iperf deamon ID:$field[$counter] was not killed \n";
                 } else {
           print LOG "The Iperf deamon ID:$field[$counter] was killed \n";
                 }
        }else {
        print LOG "Iperf service was not running\n";
        }
} #end of kill_iperf

#*************************************************************************
sub kill_all_iperf
{
   my $find_pid ="ps -e | grep iperf ";
   @iperf_pid = `$find_pid`;
   print LOG "Active IPERF PID: @iperf_pid \n";
   my $i=0;
   while ($iperf_pid[$i])
   {
     print LOG "Iperf Process: $iperf_pid[$i] \n";
     if ($iperf_pid[$i] =~ /iperf/){
     my @field = split(/\s+/, $iperf_pid[$i]);
     my $counter = 0;
     if ($field[0] eq "") {$counter++}  #skip the 1st member if blank
     if (`kill $field[$counter]`) {
           print LOG "The Iperf deamon ID:$field[$counter] was not killed \n\n";
                 } else {
           print LOG "The Iperf deamon ID:$field[$counter] was killed \n\n";
                 }
        }else {
        print LOG "Iperf service was not running\n";
        }
                                                                                                                              
     $i++;
     sleep 2;
   } #end while
} #end of kill_all_iperf


=head1 COPYRIGHT
Copyright (c) 2005, Author(s). All rights reserved.
This module is the property of Orbital Data Corporation.
It may not be used or modified by anyone without express permission
of Orbital Data Corporation.
=cut
